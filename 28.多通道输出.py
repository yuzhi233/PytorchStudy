# -*- coding: utf-8 -*-
"""
Created on Sat Feb 29 14:23:44 2020

@author: zhoubo
"""

#%%实现含多个‘输入通道’的互相关运算（卷积运算）
import torch
from torch import nn
import sys
import d2lzh_pytorch as d2l

#====================================对于多通道输入的卷积计算==============================
#这里传入的X是3维的 (chanel,h,w) 
#传入的K 也是3维的
# 计算多通道输入的卷积  结果将多个通道的计算结果进行叠加 得到一个通道的输出
def corr2d_multi_in(X, K):
    # 沿着X和K的第0维（通道维）分别计算再相加
    res = d2l.corr2d(X[0, :, :], K[0, :, :])#初始化一个res 因为维度比较抽象不好创建 X[0,:,:]等价于x[0]取出第一个代码块内的二维数组 
    for i in range(1, X.shape[0]):#注意这里的i是从1开始的 因为上面我们已经计算了 第0维和X的卷积这里从第一维开始卷积再累加
        res += d2l.corr2d(X[i, :, :], K[i, :, :])
    return res


#测试：
    
#生成一个2通道的 X 3维度 (2,3,3)  作为输入
X = torch.tensor([ [[0, 1, 2],
                    [3, 4, 5], 
                    [6, 7, 8]],
                      
                   [[1, 2, 3], 
                    [4, 5, 6],
                    [7, 8, 9]] ])


#再创建一个Kernel Kernel也应该是2个通道 是个3维的
K = torch.tensor([  [[0, 1],
                     [2, 3]],
                    [[1, 2], 
                     [3, 4]]   ])

print(corr2d_multi_in(X, K))



#======================================多通道输入卷积计算后输出多通道 输出！=================================

# 当输入通道有多个时，因为我们对各个通道的结果做了累加，所以不论输入通道数是多少，输出通道数总是为1



K = torch.stack([K, K + 1, K + 2])#相当于有3个上面的K拼到一个维度里 ，每个K就相当于一个代码块
K.shape # torch.Size([3, 2, 2, 2])

def corr2d_multi_in_out(X, K):
    # 对K的第0维遍历，每次同输入X做互相关计算。所有结果使用stack函数合并在一起
    return torch.stack([corr2d_multi_in(X, k) for k in K])#[k for k in K]是依次取出经过拼接后的K的第0维度（即代码块）的数据

print(corr2d_multi_in_out(X, K))

#=============================================1*1卷积核==========================================
# 假设我们将通道维当作特征维，将高和宽维度上的元素当成数据样本，那么1×1卷积层的作用与全连接层等价。
#
def corr2d_multi_in_out_1x1(X, K):#这里输入的X是3维度，输入的K是4维度的
    c_i, h, w = X.shape#(c,h,w)
    c_o = K.shape[0]#
    X = X.view(c_i, h * w)#把3维度的输入的图像X数组 view成 而二维的 一行是一个通道的数组 
    K = K.view(c_o, c_i)#因为输入的K也是三维的，将K先view成2维度的   有co行，ci列
    Y = torch.mm(K, X)  # 全连接层的矩阵乘法
    return Y.view(c_o, h, w)

# 在之后的模型里我们将会看到1×1卷积层被当作保持高和宽维度形状不变的全连接层使用。于是，我们可以通过调整网络层之间的通道数来控制模型复杂度。
X = torch.rand(3, 3, 3)#输入为3通道 3行3列大的数据
K = torch.rand(2, 3, 1, 1)#卷积核 为2组 3个通道的1*1卷积核

Y1 = corr2d_multi_in_out_1x1(X, K)
Y2 = corr2d_multi_in_out(X, K)
# 经验证，做1x1卷积时，以上函数与之前实现的互相关运算函数corr2d_multi_in_out等价。
# (Y1 - Y2).norm().item() < 1e-6

#吐了有点抽象，头晕>_< 不是很懂  但是大致思想知道 代码太恶心了


